#!/usr/bin/env ruby
require 'stringio'
require 'pp'
require 'optparse'
require 'find'

# TODO: Investigate ripper as an alternative to Parser:
# require 'ripper'

oldstderr, $stderr = $stderr, StringIO.new  # suppress warnings
require 'parser/current'
$stderr = oldstderr


SEARCH_DEFAULT, SEARCH_LINENO, SEARCH_REGEX = (0..2).to_a
BLUE = "\e[34m"
LIGHT_GREEN =  "\e[92m"
END_COLOR = "\e[0m"


class Matcher
  attr_accessor :lines, :offset, :look_for, :history, :matches

  def initialize(look_for, lines, offset)
    @lines = lines
    @offset = offset
    @look_for = format_look_for(look_for)
    @history = []
    @matches = []
  end
  
  def format_look_for(look_for)
    look_for
  end

  def color_line(lineno, line, line_color: "", end_color: "")
    line
  end

  def visit(node)
    history_added = 0
    lineno = node.location.line rescue nil
    @history.push(lineno) if !lineno.nil?

    match = node_matches(node)
    if match
      @matches = (matches + @history + [match]).uniq
    end

    if !node.is_a?(AST::Node) || node.children.nil? || node.children.length == 0
      return
    end

    history.push(lineno)
    node.children.each do |child|
      history.push(child.location.line) rescue nil
      visit(child)
      history.pop
    end
    history.pop

    # if node.is_a?(AST::Node) && !node.children.nil? && node.children.length > 0
    #   node.children.each { |n| visit(n) }
    # end

    if history_added > 0 && @history.length > 0
      @history.pop(history_added)
    end
  end
end


class LineNoMatcher < Matcher
  def format_look_for(lf)
    if lf.class != Array
      [lf.to_i]
    else
      lf.map(&:to_i)
    end
  end
  
  def node_matches(node)
    lineno = node.location.line rescue nil
    m = look_for.include?(lineno) ? lineno : nil
    #puts "LINENO #{lineno}, MATCH: #{m}"
    m
  end
end


class SourceCode
  attr_accessor :filename, :lines, :look_for, :num_color, :line_color, :end_color,
                :offset, :source, :number_lines, :matcher, :matches

  def initialize(source, matcher, look_for, opts={})
    @source = source
    @filename = opts[:filename]
    @offset = opts[:offset] || 1
    @lines = File.readlines(filename)
    @look_for = look_for
    @num_color = opts[:num_color] || ""
    @line_color = opts[:line_color] || ""
    @end_color = (num_color || line_color) ? END_COLOR : ""
    @matcher = matcher.new(look_for, lines, offset)
    @matches = []
  end

  def find_context
    tree = Parser::CurrentRuby.parse_file(filename)
    tree.children.each do |node|
      matcher.visit(node)
    end
    @matches = matcher.matches.sort.uniq
    puts "MATCHES: #{matches}"
    matches.map{ |i| format_line(i) }
  end
  
  def line(lineno)
    lines[lineno - offset]
  end

  def numlines
    lines.length
  end

  def format_line(lineno)
    colored_line = matcher.color_line(lineno,
                                      line(lineno),
                                      line_color: line_color,
                                      end_color: end_color)
    if number_lines
      colored_lineno = add_num_color( lineno.to_s.rjust(numlines.to_s.length) )
      "#{colored_lineno}: #{colored_line}"
    else
      colored_line
    end
  end
end

  
def main(look_for, files, search_type: SEARCH_DEFAULT,
         verbose: false, color: false)
  num_color = color ? BLUE : nil
  line_color = color ? LIGHT_GREEN : nil

  # check for recursive, walk files/directories
  all_contexts = {}
  skipped_files = {}


  oldstderr, $stderr = $stderr, StringIO.new  # suppress parse warnings

  matcher = LineNoMatcher
    
  files.each do |f|
    filename = f
    context = []

    begin
      source = SourceCode.new(f, matcher, look_for, :filename => filename, :number_lines => true,
                              :num_color => num_color, :line_color => line_color)
      context = source.find_context
    rescue SystemExit, Interrupt
      raise
    rescue => e
      if verbose == 1
        skipped_files[f] = e.inspect
      elsif verbose == 2
        skipped_files[f] = e.inspect + "\n#{e.backtrace.join("\n")}\n\n"
      end
      next
    end
    next if context.length == 0

    puts ""
    puts filename if files.length > 1
    puts context.join("")
    puts ""
  end
  $stderr = oldstderr

  if verbose > 0 && skipped_files.length > 0
    puts "Skipped these files due to errors:"
    skipped_files.each { |k, v| puts "#{k}:  #{v}" }
  end
  return all_contexts
end


if __FILE__ == $0
  options = {:verbose => 0}
  OptionParser.new do |opts|
    opts.set_banner("Find lines in a Ruby source file and the context they're in\n\n" +
                    "Usage: #{File.basename($0)} [options] look_for [paths]\n" +
                    "Options:\n")
    opts.on("-v", "--verbose", "display information about errors and skipped files") { |v| options[:verbose] += 1 }
    opts.on("-n", "--search-line", "search by line number") { |v| options[:search_type] = SEARCH_LINENO }
    opts.on("-e", "--search-regex", "search by regular expression") { |v| options[:search_type] = SEARCH_REGEX }
    opts.on("-c", "--color", "highlight line numbers and matches") { |v| options[:color] = true }
    opts.on("-h", "--help", "print this help") { puts opts; exit }
    if ARGV[0].nil?
      puts opts; exit
    end
  end.parse!

  look_for = ARGV.shift
  paths = ARGV
  # if ARGV.length > 1
  #   paths = ARGV.slice(1, ARGV.length)
  # else
  #   # TODO: not working yet, but make it read from stdin if there are no filenames passed as arguments
  #   paths = $stdin
  # end

  main(look_for, paths,
       search_type: options[:search_type] || SEARCH_DEFAULT,
       verbose: options[:verbose],
       color: options[:color])
end
