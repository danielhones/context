#!/usr/bin/env python3
import ast
import argparse
import sys
import os
import glob
import re
import itertools
import traceback


IGNORE_DIRECTORIES = ["__pycache__", ".git"]
SEARCH_LINENO, SEARCH_REGEX, SEARCH_DEFINITIONS = range(3)
SEARCH_DEFAULT = SEARCH_REGEX
BLUE = "\033[34m"
LIGHT_GREEN =  "\033[92m"
END_COLOR = "\033[0m"


class Matcher(ast.NodeVisitor):
    def __init__(self, look_for, lines, offset):
        self.lines = lines
        self.offset = offset
        self.look_for = self.format_look_for(look_for)
        self.history = []
        self.matches = []

    def format_look_for(self, look_for):
        return look_for

    def color_line(self, lineno, line):
        return line

    def generic_visit(self, node):
        try:
            self.history.append(node.lineno)
            history_added = 1
        except:
            history_added = False

        match = self.node_matches(node)
        if match:
            self.matches = self.matches + self.history + [match]
        for i in ast.iter_child_nodes(node):
            self.visit(i)

        if history_added and len(self.history) > 0:
            for _ in range(history_added):
                self.history.pop()

    def node_matches(self, node):
        """
        Must be implemented by a subclass.
        Return the line number if the node matches or None otherwise.
        """
        raise NotImplementedError("node_matches must be overridden by a subclass")


class LineNoMatcher(Matcher):
    def format_look_for(self, look_for):
        if type(look_for) not in [list, tuple]:
            return [int(look_for)]
        else:
            return [int(i) for i in look_for]

    def color_line(self, lineno, line, line_color="", end_color=""):
        if lineno in self.look_for:
            return line_color + line + end_color
        return line

    def node_matches(self, node):
        try:
            lineno = node.lineno
            return lineno if lineno in self.look_for else None
        except Exception as e:
            return None


class RegexMatcher(LineNoMatcher):
    def format_look_for(self, look_for):
        self.look_for_re = re.compile("({})".format(look_for))
        matching_lines = [i + self.offset for i, j in enumerate(self.lines)
                          if self.look_for_re.search(j)]
        return matching_lines

    def color_line(self, lineno, line, line_color="", end_color=""):
        match = self.look_for_re.search(line)
        if match:
            matched = line_color + match.group(0) + end_color
            return self.look_for_re.sub(matched, line)
        return line


class SourceCode(object):
    def __init__(self, source, matcher, look_for=None, num_color=None,
                 line_color=None, offset=1, filename='', number_lines=None):
        """
        offset is the difference between the number of the first line
        of the file and 0.  It's probably 1.
        """
        self.source = source
        self.filename = filename
        self.lines = []
        self.look_for = look_for
        self.num_color = num_color or ""
        self.line_color = line_color or ""
        self.number_lines = number_lines
        self.offset = offset
        self.end_color = END_COLOR if (num_color or line_color) else ""
        self.lines = self.source.readlines()
        self._processed_lines = self.replace_else()
        self._processed_raw = "".join(self._processed_lines)
        self.matcher = matcher(self.look_for, self.lines, self.offset)
        self.matches = []

    def find_context(self):
        tree = ast.parse(self._processed_raw, filename=self.filename)
        for node in ast.iter_child_nodes(tree):
            self.matcher.visit(node)
        self.matches = sorted(set(self.matcher.matches))
        return [self.format_line(i) for i in self.matches]

    def replace_else(self):
        # To get around the bug/feature of ast that an else line has no line number,
        # we replace it with 'elif True' before parsing, but display the original
        # line in the results
        else_re = re.compile('^(?P<space> *)(else:)')
        return [else_re.sub(r"\g<space>elif True:", i) for i in self.lines]

    def line(self, lineno):
        return self.lines[lineno - self.offset]

    @property
    def numlines(self):
        return len(self.lines)

    def add_num_color(self, lineno):
        return self.num_color + lineno + self.end_color

    def format_line(self, lineno):
        line = self.line(lineno)
        colored_line = self.matcher.color_line(lineno,
                                               line,
                                               line_color=self.line_color,
                                               end_color=self.end_color)
        if self.number_lines:
            num_padding = len(str(self.numlines))
            colored_num = self.add_num_color(str(lineno).rjust(num_padding))
            return "{}: {}".format(colored_num, colored_line)
        else:
            return colored_line


def main(look_for, files, search_type=None, ignore=None,
         verbose=False, color=False, number_lines=False):
    """
    look_for is a string, files is a list of paths
    """
    num_color = BLUE if color else None
    line_color = LIGHT_GREEN if color else None
    all_contexts = {}
    skipped_files = {}
    if search_type is None:
        search_type = SEARCH_DEFAULT

    # TODO: need to make this handle the recursive option
    if type(files) != list:
        files = [files]

    if search_type == SEARCH_REGEX:
        matcher = RegexMatcher
    elif search_type == SEARCH_LINENO:
        matcher = LineNoMatcher

    for f in files:
        # TODO: need to handle the ignore option here
        try:
            source = SourceCode(f, matcher, look_for, filename=f.name,
                                line_color=line_color, num_color=num_color,
                                number_lines=number_lines)
            result = source.find_context()
            if result:
                sys.stdout.write("\n" + f.name + "\n\n" +
                                 "".join(result) +
                                 "\n")
                all_contexts[f.name] = result
        except Exception as e:
            skipped_files[f.name] = e

    if verbose and skipped_files:
        sys.stdout.write("\nSkipped these files due to errors:\n")
        [sys.stdout.write("{}: {}\n".format(key, skipped_files[key])) for key in skipped_files]

    return all_contexts


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Find lines in a Python source file and the context they're in."
    )
    parser.add_argument("look_for",
                        help=("Object to look for in the file.  For certain search"
                              "types this can be a comma-separated list or a Python"
                              "list such as [6,8,10]"))
    parser.add_argument("paths",
                        nargs="*",
                        type=argparse.FileType('r'),
                        default=sys.stdin,
                        help=("Files (or directories if -r option) to look in. "
                              "If there is no argument passed here, read from STDIN"))
    parser.add_argument("-c", "--color", action="store_true", help="colorize output")
    parser.add_argument("-n", "--number-lines", action="store_true", dest="number_lines",
                        help="include line numbers in results")
    parser.add_argument("-l", "--search-line", dest="search_type",
                        action="store_const", const=SEARCH_LINENO,
                        help="Search by line number.  Allows a list as the look_for argument")
    parser.add_argument("-e", "--search-regex", dest="search_type", action="store_const",
                        const=SEARCH_REGEX, help="search by regexp")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Display information about errors and skipped files")
    args = parser.parse_args()

    look_for = args.look_for
    if args.search_type == SEARCH_LINENO:
        try:
            look_for = eval(args.look_for)
        except:
            pass

    main(look_for,
         args.paths,
         search_type=args.search_type,
         verbose=args.verbose,
         color=args.color,
         number_lines=args.number_lines)
