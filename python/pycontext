#!/usr/bin/env python3
import argparse
import ast
import glob
import itertools
import os
import re
import sys
import traceback


SEARCH_LINENO, SEARCH_REGEX, SEARCH_DEFINITIONS = range(3)
SEARCH_DEFAULT = SEARCH_REGEX
BLUE = "\033[34m"
LIGHT_GREEN =  "\033[92m"
END_COLOR = "\033[0m"


def insert_term_color(string, start, end, color):
    return string[:start] + color + string[start:end] + END_COLOR + string[end:]


class Matcher(ast.NodeVisitor):
    def __init__(self, look_for, lines, offset=1):
        self.lines = lines
        self.offset = offset
        self.look_for = self.format_look_for(look_for)
        self.history = []
        self.matches = []

    def format_look_for(self, look_for):
        return look_for

    def color_line(self, lineno, line, line_color=None):
        return line

    def generic_visit(self, node):
        try:
            self.history.append(node.lineno)
            history_added = 1
        except:
            history_added = False

        match = self.node_matches(node)
        if match:
            self.matches = self.matches + self.history + [match]
        for i in ast.iter_child_nodes(node):
            self.visit(i)

        if history_added and len(self.history) > 0:
            for _ in range(history_added):
                self.history.pop()

    def node_matches(self, node):
        """
        Must be implemented by a subclass.
        Return the line number if the node matches or None otherwise.
        """
        raise NotImplementedError("node_matches must be overridden by a subclass")


class LineNoMatcher(Matcher):
    def format_look_for(self, look_for):
        if type(look_for) not in [list, tuple]:
            return [int(look_for)]
        else:
            return [int(i) for i in look_for]

    def color_line(self, lineno, line, line_color=None):
        if lineno in self.look_for and line_color is not None:
            return insert_term_color(line, 0, len(line), line_color)
        return line

    def node_matches(self, node):
        try:
            lineno = node.lineno
            return lineno if lineno in self.look_for else None
        except Exception as e:
            return None


class RegexMatcher(LineNoMatcher):
    def format_look_for(self, look_for):
        self.look_for_re = re.compile("({})".format(look_for))
        # This looks strange, but the idea here is to find the lines that match our regex,
        # then use the LineNoMatcher.node_matches to indicate that those lines match
        matching_lines = [i + self.offset for i, j in enumerate(self.lines)
                          if self.look_for_re.search(j)]
        return matching_lines

    def color_line(self, lineno, line, line_color=None):
        match = self.look_for_re.search(line)
        if match and line_color is not None:
            return insert_term_color(line, match.span()[0], match.span()[1], line_color)
        return line


class SourceCode(object):
    def __init__(self, source, matcher_class, look_for=None, num_color=None,
                 line_color=None, offset=1, filename='', number_lines=None):
        """
        offset is the difference between the number of the first line
        of the file and 0.  It's probably 1.
        """
        self.source = source
        self.filename = filename
        self.lines = []
        self.look_for = look_for
        self.num_color = num_color
        self.line_color = line_color
        self.number_lines = number_lines
        self.offset = offset
        self.lines = self.source.readlines()
        self.raw_source = "".join(self.lines)
        self.matcher = matcher_class(self.look_for, self.lines, self.offset)
        self.matches = []

    def find_context(self):
        tree = ast.parse(self.raw_source, filename=self.filename)
        for node in ast.iter_child_nodes(tree):
            self.matcher.visit(node)
        self.matches = sorted(set(self.matcher.matches))
        return [self.format_line(i) for i in self.matches]

    def line(self, lineno):
        return self.lines[lineno - self.offset]

    @property
    def numlines(self):
        return len(self.lines)

    def add_num_color(self, lineno):
        if self.num_color is not None:
            return insert_term_color(lineno, 0, len(lineno), self.num_color)
        return lineno

    def format_line(self, lineno):
        line = self.line(lineno)
        colored_line = self.matcher.color_line(lineno,
                                               line,
                                               line_color=self.line_color)
        if self.number_lines:
            num_padding = len(str(self.numlines))
            colored_num = self.add_num_color(str(lineno).rjust(num_padding))
            return "{}: {}".format(colored_num, colored_line)
        else:
            return colored_line


def main(look_for, files, search_type=None, ignore=None, verbose=False, color=False,
         number_lines=False, output=sys.stdout, errout=sys.stderr):
    """
    look_for is a string, files is a list of paths
    """
    num_color = BLUE if color else None
    line_color = LIGHT_GREEN if color else None
    all_contexts = {}
    skipped_files = {}
    if search_type is None:
        search_type = SEARCH_DEFAULT

    if type(files) != list:
        files = [files]

    if search_type == SEARCH_REGEX:
        matcher = RegexMatcher
    elif search_type == SEARCH_LINENO:
        matcher = LineNoMatcher

    for f in files:
        try:
            source = SourceCode(f, matcher, look_for, filename=f.name,
                                line_color=line_color, num_color=num_color,
                                number_lines=number_lines)
            context = source.find_context()
            if context:
                result = ["\n", f.name, "\n\n"] if len(files) > 1 else ["\n"]
                result += context
                result.append("\n")
                output.write("".join(result))
                all_contexts[f.name] = context
        except Exception as e:
            skipped_files[f.name] = e

    if verbose and skipped_files:
        errout.write("\nSkipped these files due to errors:\n")
        [errout.write("{}: {}\n".format(key, skipped_files[key])) for key in skipped_files]

    return all_contexts


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Find lines in a Python source file and the context they're in."
    )
    parser.add_argument("look_for",
                        help=("Object to look for in the file.  For certain search"
                              "types this can be a comma-separated list such as \"6,8,10\""))
    parser.add_argument("paths",
                        nargs="*",
                        type=argparse.FileType('r'),
                        default=sys.stdin,
                        help=("Files to look in. If there is no argument passed here, read from STDIN"))
    parser.add_argument("-c", "--color", action="store_true", help="colorize output")
    parser.add_argument("-n", "--number-lines", action="store_true", dest="number_lines",
                        help="include line numbers in results")
    parser.add_argument("-l", "--search-line", dest="search_type",
                        action="store_const", const=SEARCH_LINENO,
                        help="Search by line number.  Allows a list as the look_for argument")
    parser.add_argument("-e", "--search-regex", dest="search_type", action="store_const",
                        const=SEARCH_REGEX, help="search by regexp")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Display information about errors and skipped files")
    args = parser.parse_args()

    look_for = args.look_for
    if args.search_type == SEARCH_LINENO:
        try:
            look_for = args.look_for.split(',')
        except:
            pass

    main(look_for,
         args.paths,
         search_type=args.search_type,
         verbose=args.verbose,
         color=args.color,
         number_lines=args.number_lines)
