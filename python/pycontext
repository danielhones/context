#!/usr/bin/env python3
import ast
import argparse
import sys
import os
import glob
import re
import itertools


IGNORE_DIRECTORIES = ["__pycache__", ".git"]
SEARCH_LINENO, SEARCH_REGEX, SEARCH_DEFINITIONS = range(3)
SEARCH_DEFAULT = SEARCH_REGEX
BLUE = "\033[34m"
LIGHT_GREEN =  "\033[92m"
END_COLOR = "\033[0m"


class Matcher(ast.NodeVisitor):
    def __init__(self, look_for):
        self.look_for = self.format_look_for(look_for)
        self.history = []
        self.matches = []

    def format_look_for(self, look_for):
        return look_for

    def color_line(self, lineno, line):
        return line

    def generic_visit(self, node):
        try:
            self.history.append(node.lineno)
            history_added = True
        except:
            history_added = False

        match = self.node_matches(node)
        if match:
            self.matches = self.matches + self.history + [match]
        for i in ast.iter_child_nodes(node):
            self.visit(i)

        if len(self.history) > 0 and history_added:
            self.history.pop()

    def node_matches(self, node):
        """
        Must be implemented by a subclass.
        Return the line number if the node matches or None otherwise.
        """
        raise NotImplementedError("node_matches must be overridden by a subclass")


class LineNoMatcher(Matcher):
    def format_look_for(self, look_for):
        return int(look_for)

    def color_line(self, lineno, line):
        if lineno == self.look_for:
            return "{line_color}{line}{end_color}"
        return line

    def node_matches(self, node):
        try:
            lineno = node.lineno
            return lineno if lineno == self.look_for else None
        except Exception as e:
            return None


class RegexMatcher(Matcher):
    def format_look_for(self, look_for):
        return re.compile(look_for)


class SourceCode(object):
    def __init__(self, source, matcher, look_for=None, num_color=None,
                 line_color=None, offset=1, filename=''):
        """
        offset is the difference between the number of the first line
        of the file and 0.  It's probably 1.
        """
        self.source = source
        self.matcher = matcher
        self.filename = filename
        self.lines = []
        self.look_for = look_for
        self.num_color = num_color or ""
        self.line_color = line_color or ""
        self.offset = offset
        self.end_color = END_COLOR if (num_color or line_color) else ""
        self.lines = self.source.readlines()
        self._raw = "".join(self.lines)
        self.matches = []

    def find_context(self):
        tree = ast.parse(self._raw, filename=self.filename)
        for node in ast.iter_child_nodes(tree):
            self.matcher.visit(node)
        self.matches = sorted(set(self.matcher.matches))
        return [self.format_line(i) for i in self.matches]

    def line(self, lineno):
        return self.lines[lineno - self.offset]

    @property
    def numlines(self):
        return len(self.lines)

    def add_num_color(self, lineno):
        return self.num_color + lineno + self.end_color

    def format_line(self, lineno):
        num_padding = len(str(self.numlines))
        colored_num = self.add_num_color(str(lineno).rjust(num_padding))
        line = self.line(lineno)
        template_line = self.matcher.color_line(lineno, line)
        colored_line = template_line.format(line_color=self.line_color,
                                            line=line,
                                            end_color=self.end_color)
        return "{}:  {}".format(colored_num, colored_line)


def main(look_for, files, search_type=SEARCH_DEFAULT, recursive=False,
         ignore=IGNORE_DIRECTORIES, verbose=False, color=False):
    """
    look_for is a string, files is a list of paths
    """
    num_color = BLUE if color else None
    line_color = LIGHT_GREEN if color else None
    all_contexts = {}
    skipped_files = {}

    # TODO: need to make this handle the recursive option
    if type(files) != list:
        files = [files]

    if search_type == SEARCH_REGEX:
        matcher = RegexMatcher(look_for)
    elif search_type == SEARCH_LINENO:
        matcher = LineNoMatcher(look_for)

    for f in files:
        # TODO: need to handle the ignore option here
        try:
            source = SourceCode(f, matcher, filename=f.name,
                                line_color=line_color, num_color=num_color)
            result = source.find_context()
            sys.stdout.write("\n" + f.name + "\n\n" +
                             "".join(result) +
                             "\n")
            all_contexts[f.name] = result
        except Exception as e:
            skipped_files[f.name] = e

    return all_contexts


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Find lines in a Python source file and the context they're in."
    )
    parser.add_argument("look_for", help="object to look for in the file")
    parser.add_argument("paths",
                        nargs="*",  # TODO: try nargs="*" here for multiple
                        type=argparse.FileType('r'),
                        default=sys.stdin,
                        help="files (or directories if -r option) to look in")
    parser.add_argument("-r", "--recursive", action="store_true",
                        help="recursively search directory")
    parser.add_argument("-c", "--color", action="store_true", help="colorize output")
    parser.add_argument("-n", "--search-line", dest="search_type",
                        action="store_const", const=SEARCH_LINENO,
                        help="search by line number")
    parser.add_argument("-e", "--search-regex", dest="search_type", action="store_const",
                        const=SEARCH_REGEX, help="search by regexp")
    parser.add_argument("-d", "--search-defs", dest="search_type",
                        action="store_const", const=SEARCH_DEFINITIONS,
                        help=("just look for class and function definitions.  The look_for argument "
                              "should be an integer indicating the maxmimum depth of search"))
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="display information about errors and skipped files")
    parser.add_argument("-i", "--ignore",
                        help=("comma-separated list of files and directories "
                              "to ignore, default is {}".format(IGNORE_DIRECTORIES)))
    args = parser.parse_args()

    if args.ignore:
        ignore = args.ignore.split(",") + IGNORE_DIRECTORIES
    else:
        ignore = IGNORE_DIRECTORIES

    main(args.look_for,
         args.paths,
         search_type=args.search_type,
         recursive=args.recursive,
         ignore=ignore,
         verbose=args.verbose,
         color=args.color)
