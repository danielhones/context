#!/usr/bin/env python3
import ast
# import astroid
import argparse
import sys
import os
import glob
import re
import itertools


IGNORE_DIRECTORIES = ["__pycache__", ".git"]
SEARCH_LINENO, SEARCH_REGEX, SEARCH_DEFINITIONS = range(3)
SEARCH_DEFAULT = SEARCH_REGEX
BLUE = "\033[34m"
LIGHT_GREEN =  "\033[92m"
END_COLOR = "\033[0m"


class Matcher(ast.NodeVisitor):
    def __init__(self, look_for, lines, offset):
        self.lines = lines
        self.offset = offset
        self.look_for = self.format_look_for(look_for)
        self.history = []
        self.matches = []

    def format_look_for(self, look_for):
        return look_for

    def color_line(self, lineno, line):
        return line

    def generic_visit(self, node):
        # TODO: This method still has the bug of not including lines that say "else:"
        #       Figure out why and fix it.  Also look for other cases of similar bugs
        #       and write some tests to catch them.
        # NOTE: This is because there is no actual "Else" node, only an 'orelse' field
        #       on the "If" node, which only contains the body of the else block.  So
        #       there's not actually any node that has the lineno of an 'else:' line.
        #       Not sure what to do about this.

        try:
            self.history.append(node.lineno)
            history_added = 1
            # else clauses need special handling and we resort to this heuristic
            # to get the line number:

        except:
            history_added = False

        # print("INSPECTING:", node)
        # for k, v in ast.iter_fields(node):
        #     print("FIELD: ", k, v)

        match = self.node_matches(node)
        if match:
            self.matches = self.matches + self.history + [match]
        for i in ast.iter_child_nodes(node):
            self.visit(i)

        if history_added and len(self.history) > 0:
            for _ in range(history_added):
                self.history.pop()

    def node_matches(self, node):
        """
        Must be implemented by a subclass.
        Return the line number if the node matches or None otherwise.
        """
        raise NotImplementedError("node_matches must be overridden by a subclass")


class LineNoMatcher(Matcher):
    def format_look_for(self, look_for):
        if type(look_for) not in [list, tuple]:
            return [int(look_for)]
        else:
            return [int(i) for i in look_for]

    def color_line(self, lineno, line):
        if lineno in self.look_for:
            return "{line_color}{line}{end_color}"
        return line

    def node_matches(self, node):
        try:
            lineno = node.lineno
            return lineno if lineno in self.look_for else None
        except Exception as e:
            return None


class RegexMatcher(LineNoMatcher):
    def format_look_for(self, look_for):
        self.look_for_re = re.compile("({})".format(look_for))
        matching_lines = [i + self.offset for i, j in enumerate(self.lines)
                          if self.look_for_re.search(j)]
        return matching_lines

    def color_line(self, lineno, line):
        match = self.look_for_re.search(line)
        if match:
            matched = "{line_color}" + match.group(0) + "{end_color}"
            return self.look_for_re.sub(matched, line)
        return line


class SourceCode(object):
    def __init__(self, source, matcher, look_for=None, num_color=None,
                 line_color=None, offset=1, filename=''):
        """
        offset is the difference between the number of the first line
        of the file and 0.  It's probably 1.
        """
        self.source = source
        self.filename = filename
        self.lines = []
        self.look_for = look_for
        self.num_color = num_color or ""
        self.line_color = line_color or ""
        self.offset = offset
        self.end_color = END_COLOR if (num_color or line_color) else ""
        self.lines = self.source.readlines()
        self._raw = "".join(self.lines)
        self.matcher = matcher(self.look_for, self.lines, self.offset)
        self.matches = []

    def find_context(self):
        tree = ast.parse(self._raw, filename=self.filename)
        for node in ast.iter_child_nodes(tree):
            self.matcher.visit(node)
        self.matches = sorted(set(self.matcher.matches))
        return [self.format_line(i) for i in self.matches]

    def line(self, lineno):
        return self.lines[lineno - self.offset]

    @property
    def numlines(self):
        return len(self.lines)

    def add_num_color(self, lineno):
        return self.num_color + lineno + self.end_color

    def format_line(self, lineno):
        num_padding = len(str(self.numlines))
        colored_num = self.add_num_color(str(lineno).rjust(num_padding))
        line = self.line(lineno)
        template_line = self.matcher.color_line(lineno, line)
        colored_line = template_line.format(line_color=self.line_color,
                                            line=line,
                                            end_color=self.end_color)
        return "{}:  {}".format(colored_num, colored_line)


def main(look_for, files, search_type=None, recursive=False,
         ignore=IGNORE_DIRECTORIES, verbose=False, color=False):
    """
    look_for is a string, files is a list of paths
    """
    num_color = BLUE if color else None
    line_color = LIGHT_GREEN if color else None
    all_contexts = {}
    skipped_files = {}
    if search_type is None:
        search_type = SEARCH_DEFAULT

    # TODO: need to make this handle the recursive option
    if type(files) != list:
        files = [files]

    if search_type == SEARCH_REGEX:
        matcher = RegexMatcher
    elif search_type == SEARCH_LINENO:
        matcher = LineNoMatcher

    for f in files:
        # TODO: need to handle the ignore option here
        try:
            source = SourceCode(f, matcher, look_for, filename=f.name,
                                line_color=line_color, num_color=num_color)
            result = source.find_context()
            sys.stdout.write("\n" + f.name + "\n\n" +
                             "".join(result) +
                             "\n")
            all_contexts[f.name] = result
        except Exception as e:
            skipped_files[f.name] = e

    if verbose and skipped_files:
        sys.stdout.write("\nSkipped these files due to errors:\n")
        [sys.stdout.write("{}: {}\n".format(key, skipped_files[key])) for key in skipped_files]

    return all_contexts


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Find lines in a Python source file and the context they're in."
    )
    parser.add_argument("look_for",
                        help=("Object to look for in the file.  For certain search"
                              "types this can be a comma-separated list or a Python"
                              "list such as [6,8,10]"))
    parser.add_argument("paths",
                        nargs="*",
                        type=argparse.FileType('r'),
                        default=sys.stdin,
                        help=("Files (or directories if -r option) to look in. "
                              "If there is no argument passed here, read from STDIN"))
    parser.add_argument("-r", "--recursive", action="store_true",
                        help="Recursively search directory")
    parser.add_argument("-c", "--color", action="store_true", help="colorize output")
    parser.add_argument("-n", "--search-line", dest="search_type",
                        action="store_const", const=SEARCH_LINENO,
                        help="Search by line number.  Allows a list as the look_for argument")
    parser.add_argument("-e", "--search-regex", dest="search_type", action="store_const",
                        const=SEARCH_REGEX, help="search by regexp")
    # parser.add_argument("-d", "--search-defs", dest="search_type",
    #                     action="store_const", const=SEARCH_DEFINITIONS,
    #                     help=("Just look for class and function definitions.  The look_for argument "
    #                           "Should be an integer indicating the maxmimum depth of search"))
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Display information about errors and skipped files")
    parser.add_argument("-i", "--ignore",
                        help=("Comma-separated list of files and directories "
                              "to ignore, default is {}".format(IGNORE_DIRECTORIES)))
    args = parser.parse_args()

    if args.ignore:
        ignore = args.ignore.split(",") + IGNORE_DIRECTORIES
    else:
        ignore = IGNORE_DIRECTORIES


    look_for = args.look_for
    if args.search_type == SEARCH_LINENO:
        try:
            look_for = eval(args.look_for)
        except:
            pass

    main(look_for,
         args.paths,
         search_type=args.search_type,
         recursive=args.recursive,
         ignore=ignore,
         verbose=args.verbose,
         color=args.color)
